<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on A Humbly Arrogant Blog</title>
    <link>http://blog.humblyarrogant.io/categories/golang/index.xml</link>
    <description>Recent content in Golang on A Humbly Arrogant Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <copyright>Iain Cambridge, all rights reserved.</copyright>
    <atom:link href="http://blog.humblyarrogant.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go dep in Docker</title>
      <link>http://blog.humblyarrogant.io/post/2017-02-04-Go-dep-in-docker/</link>
      <pubDate>Sat, 04 Feb 2017 15:12:23 +0100</pubDate>
      
      <guid>http://blog.humblyarrogant.io/post/2017-02-04-Go-dep-in-docker/</guid>
      <description>&lt;p&gt;Go&amp;rsquo;s dependency handling has been an area which has been needing unification, over the years. Multiple package managers have been created. The Go community has been working on creating a dependency manager recently, which they plan on getting added to the official toolchain. I&amp;rsquo;ve decided to jump on the bandwagon and start using this tool. Here&amp;rsquo;s how I&amp;rsquo;ve been using it in docker.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The first issue I encountered was the command &lt;code&gt;dep&lt;/code&gt; not being found. It turned out my original docker build file had &lt;code&gt;GOBIN&lt;/code&gt; pointed to somewhere that was not in the &lt;code&gt;PATH&lt;/code&gt; env for some reason. Looking at the original &lt;code&gt;Dockerfile&lt;/code&gt; for golang it &lt;code&gt;GOBIN&lt;/code&gt; doesn&amp;rsquo;t appear to be set at all. So I&amp;rsquo;ve set it to &lt;code&gt;/go/bin&lt;/code&gt; which has already been added to the path.&lt;/p&gt;

&lt;p&gt;The next issue was, I was storing and building my code outside of the &lt;code&gt;GOPATH&lt;/code&gt;. So I moved where I was storing my code to inside the &lt;code&gt;GOPATH&lt;/code&gt;. With that done it was just a case of running the &lt;code&gt;dep&lt;/code&gt; commands.&lt;/p&gt;

&lt;p&gt;An example &lt;code&gt;Dockerfile&lt;/code&gt; can be found below.&lt;/p&gt;

&lt;p&gt;{% gist 163763cd1017d8a5319c0c48ec697969 Dockerfile %}&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Revel : Force template format</title>
      <link>http://blog.humblyarrogant.io/post/2014-04-26-revel-force-template-format/</link>
      <pubDate>Sat, 26 Apr 2014 15:39:14 -0400</pubDate>
      
      <guid>http://blog.humblyarrogant.io/post/2014-04-26-revel-force-template-format/</guid>
      <description>&lt;p&gt;So in Revel you can have your template in several different formats: html, json, xml, or txt. This is super awesome. As it allows you to send the same data and display different formats - Obivously. It also determines what template to use based on the http request headers that have been sent. So if your request sends that it accepts application/xml it&amp;rsquo;ll use xml and if you request says application/json it uses json.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;All awesome. But what if I want to debug something that should only ever be json. Or even more interesting what if I sent that I accept html and json but with json second in the list. AngularJS seems to do this by default, took me a while to figure out what was going on. So I need a way of forcing revel to just use one file format no matter what the http headers are. Thankfully it&amp;rsquo;s super simple, one line in your controller action to set the Request member&amp;rsquo;s Format member to the desired format and it&amp;rsquo;ll use that.&lt;/p&gt;

&lt;p&gt;{% gist 11321687 snippet.go %}&lt;/p&gt;

&lt;p&gt;So in full example.&lt;/p&gt;

&lt;p&gt;{% gist 11321687 test.go %}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Observer pattern in golang</title>
      <link>http://blog.humblyarrogant.io/post/2014-03-22-observer-pattern-in-golang/</link>
      <pubDate>Sat, 22 Mar 2014 10:37:14 -0400</pubDate>
      
      <guid>http://blog.humblyarrogant.io/post/2014-03-22-observer-pattern-in-golang/</guid>
      <description>

&lt;p&gt;For some reason at some point, I thought it would be hard to implement the observer pattern in Go. Then I made an issue for me to blog about it. Well it&amp;rsquo;s not hard. It&amp;rsquo;s as easy as it is in every
other language.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;observers&#34;&gt;Observers&lt;/h1&gt;

&lt;p&gt;First part of the observer pattern is you need the actual observers. The logic that you want executed whenever something happens. Here I&amp;rsquo;ve just put a simple log print statement that will print out the name of the hook to the log.&lt;/p&gt;

&lt;p&gt;Created an interface to allow for more flexible typing later on.&lt;/p&gt;

&lt;p&gt;{% gist 9708081 interface.go %}&lt;/p&gt;

&lt;h1 id=&#34;observer-notifier&#34;&gt;Observer Notifier&lt;/h1&gt;

&lt;p&gt;The main part of the logic, simply have an add observer and then have a process function that loops through and calls them all.&lt;/p&gt;

&lt;p&gt;{% gist 9708081 observer.go %}&lt;/p&gt;

&lt;h1 id=&#34;full&#34;&gt;Full&lt;/h1&gt;

&lt;p&gt;Here is a copy of it all together. As you can see it&amp;rsquo;s really simple to whack together once you have a half decent understanding of Go.&lt;/p&gt;

&lt;p&gt;{% gist 9708081 main.go %}&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>